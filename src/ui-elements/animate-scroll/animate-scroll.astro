---
import { cls } from '@/src/lib/utils';

interface Props {
   class?:string;
   threshold?:number
}

const {  class:className, threshold } = Astro.props as Props;

const merge = cls(
    "block [&>.active-item]:opacity-100 [&>.active-item]:translate-y-0 [&>.active-item]:scale-100 [&>.active-item]:duration-500 [&>.active-item]:ease-out [&>.inactive-item]:opacity-0 [&>.inactive-item]:translate-y-6 [&>.inactive-item]:scale-95 [&>.inactive-item]:duration-500 [&>.inactive-item]:ease-in",
    className
)

---

<wrapper-observer 
data-threshold={threshold}
  class={merge}
>
  <slot />
</wrapper-observer>


<script is:inline>
    if (!window.__WRAPPER_OBSERVER_LOADED) {
        window.__WRAPPER_OBSERVER_LOADED = true;

        (function () {
            const TAG = "wrapper-observer";

            class WrapperObserver extends HTMLElement {
                constructor() {
                    super();

                    // Shadow DOM encapsulado
                    const shadow = this.attachShadow({ mode: "open" });

                    // Slot real del Web Component
                    this._slot = document.createElement("slot");
                    shadow.appendChild(this._slot);

                    this._observer = null;

                    // Re-observar elementos cuando cambian
                    this._slot.addEventListener("slotchange", () => {
                        this._observeChildren();
                    });
                }

                connectedCallback() {
                    this._createObserver();
                    this._observeChildren();
                }

                disconnectedCallback() {
                    if (this._observer) this._observer.disconnect();
                }

                _createObserver() {
                    if (this._observer) return;

                    const threshold = parseFloat(this.dataset.threshold || "0.5");

                    this._observer = new IntersectionObserver(
                        (entries) => {
                            for (const entry of entries) {
                                const el = entry.target;

                                const visible = "active-item"
                                const hidden = "inactive-item"
                              
                                if (entry.isIntersecting) {
                                    el.classList.add(visible);
                                    el.classList.remove(hidden);
                                } else {
                                    el.classList.remove(visible);
                                    el.classList.add(hidden);
                                }
                            }
                        },
                        {
                            root: null,
                            threshold: threshold,
                        },
                    );
                }

                _observeChildren() {
                    if (!this._observer) return;

                    this._observer.disconnect();

                    // SOLO hijos directos â†’ como React children
                    const children = this._slot.assignedElements({
                        flatten: false,
                    });

                    for (const child of children) {
                        this._observer.observe(child);
                    }
                }
            }

            customElements.define(TAG, WrapperObserver);
        })();
    }
</script>